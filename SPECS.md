## vmcast — Product and Technical Specifications

### Overview
vmcast is a privacy-first voice messaging app for long-form voice messages with a playback experience comparable to audiobook/podcast players. Messages are end-to-end encrypted, delivered via decentralized store-and-forward relays, and stored locally on-device. Advanced features such as transcription, summaries, and table of contents are powered by on-device AI models (no cloud AI APIs).

### MVP scope
- Reliable recording (survives lock and brief interruptions where OS allows), sending, receiving, and playback of long-form voice messages (VMs)
- End-to-end encryption for audio and status receipts (delivered/listened)
- Local storage only; manual delete; optional OS-level backup (opt-in)
- Contact model with username/QR exchange; no contact book access
- Push notifications with privacy-preserving generic content
- Playback UX: mini-player, continuous play, global speed control (0.5–3.0x), ±10s skip, simple position seek bar
- On-device AI: post-recording transcription, searchable transcripts, summaries, and table of contents with jump-to sections
- Global and per-thread search over transcripts and metadata (offline)

### Platforms and UX
- Flutter app targeting Android and iOS
- Design: Material 3 across platforms where possible; on iOS prefer native navigation/sheets/haptics and iOS glass/blur accents where appropriate (platform-adaptive)
- Primary screens: Contacts → VM List → VM Detail; plus Record/Compose and Settings; optional simple Profile (username/QR)

## Architecture overview
- App layers: UI (Flutter) → Domain (messaging, playback, AI) → Data (SQLite/FTS, file store) → Crypto (libsignal) → Transport (relays)
- Local data: SQLite (Drift) with FTS5, audio files in app sandbox (content-addressed), transcripts/AI artifacts stored locally
- No central backend; decentralized relays for envelopes and media chunks; push used only as wake-up hints

## Transport and relays (decentralized)
- Model: decentralized store-and-forward using purpose-built relays
  - Message relays: WebSocket/HTTP2; accept encrypted envelopes, maintain per-recipient queues; configurable retention and rate limiting
  - Media relays: HTTP chunked uploads (1–4 MB chunks), resumable via manifests; blobs identified by BLAKE3 content hashes
- Client behavior
  - Maintain an outbox with retry/backoff and resumable uploads
  - Use one or more public relays; ship with a bootstrap list of default public relays for easy onboarding; users can add/remove relays; per-contact relay preferences
  - Offline delivery: relays queue until recipient fetches
- Push: APNs/FCM generic notifications; encrypted hint prompting client to poll relays; no sender or preview in payload
- Note: No Nostr integration or compatibility in MVP to keep the system clean and consistent

## Security and E2EE
- Protocol: X3DH + Double Ratchet using libsignal for per-contact sessions
- Scope: encrypt audio blobs, message envelopes, and status receipts end-to-end
- Metadata minimization: relays see only encrypted envelopes and opaque blob identifiers; no plaintext sender/recipient in headers
- Identity and keys: per-device identity keys (X25519 + Ed25519), stored in OS Keychain/Keystore; no multi-device sync
- Deletion: hard delete on device; no guaranteed remote deletion; relay retention via TTL/GC

## Contacts and identity
- Primary: username/QR-based exchange (privacy-first)
- Optional later: phone verification and private discovery flows (non-MVP)

## Audio pipeline
### Recording
- Max duration: up to 90 minutes per VM
- Format: Opus in Ogg container, mono, 16 kHz sample rate, ~16–24 kbps target
- Fallback on iOS: AAC-LC (.m4a) if hardware/OS constraints require
- Reliability: continues through screen lock and brief interruptions where OS allows; background audio mode enabled; automatic temp-file + atomic move; crash recovery
- Processing: platform-native noise suppression and AGC where available; mono capture to reduce size and improve intelligibility

### Playback
- Mini-player pinned across app; VM Detail screen with full controls
- Controls: fixed ±10s skip; simple position seek bar; continuous play of lists
- Speed: global playback speed setting with steps 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0
- Remember global playback speed across sessions; optional per-VM remembered last position

## On-device AI (no cloud APIs)
- Runtime: whisper.cpp for ASR; llama.cpp/MLC for small LLM inference (e.g., Phi-3-mini or 3–7B quantized such as Q4_K_M); download model packs (optional later also based on device capability)
- Transcription: post-recording only (during listening), with language detection; generate timestamped segments and store locally
- Summaries: short abstractive summaries generated by the local LLM
- Table of contents (ToC): generate section boundaries and titles with timestamps; tap-to-seek
- Controls: user chooses auto-transcribe on receipt or on-demand; heavy inference can be limited to charging/Wi‑Fi; clear disk usage of model packs

## Search
- SQLite with FTS5 index, fully offline
- Scopes: global (entire on-device library) and local (per contact/thread)
- Indexed fields: transcript text; metadata such as contact, createdAt
- Queries: phrase, prefix, fuzzy; filters by date/contact

## Data model (high-level)
- Contact { id(pubkey), displayName, username, relayUrls[] }
- VM { id, contactId, createdAt, duration, format, fileHash, localPath, state(queued|sent|delivered|listened), transcriptId?, summaryId?, tocId?, flags{starred, hasTranscript} }
- Transcript { id, vmId, lang, segments[] { start, end, text } }
- Summary { id, vmId, text }
- ToC { id, vmId, sections[] { start, title } }
- RelayConfig { urls[], auth? }
- Settings { playbackSpeedDefault, skipSeconds=10, autoTranscribe, modelPrefs, backupOptIn }

## Table of contents generation (algorithm v1)
LLM-first approach for quality:
1) Generate initial coarse sections using a local LLM over the full transcript with timestamps (windowed if needed). Ask the model to produce concise, user-friendly titles and approximate start times.
2) Align and refine boundaries by snapping to nearest Whisper timestamps and adjusting for minimum section duration.
3) Optional heuristic pass: use silence gaps and discourse markers only when LLM confidence is low or sections are too short/long.
4) Persist ToC; tapping a section seeks playback to its start. Allow user edits to section titles.

## Messaging states and receipts
- States: queued → sent (to relays) → delivered (recipient fetched) → listened (playback started)
- Receipts: delivered/listened are end-to-end encrypted status messages; listening receipts can be disabled by user

## Storage and backup
- Local-only by default; no multi-device sync
- OS-level backup (only as archive): opt-in (user controls via Settings)
- Storage layout: audio blobs in sandbox with content-addressed filenames; SQLite DB for metadata and FTS; JSON sidecars for transcripts/AI artifacts if needed
- No auto-delete; provide storage usage views and manual cleanup tools
- Low-storage warnings with actionable guidance

## Push notifications
- APNs/FCM with generic payloads (no sender/message preview)
- Encrypted hint to prompt client fetch from relays; decryption and message display are on-device only
- Abstraction layer to optionally add other vendors later

## Networking and scaling
- Horizontal scaling by adding relays; clients may use multiple relays for redundancy
- Integrity: BLAKE3 hashes for media chunks and manifests; verify on download
- Abuse controls: per-identity rate limiting and optional lightweight proof-of-work tokens

## Settings (initial)
- Playback: default speed, skip interval (fixed 10s UI), continuous play toggle
- AI: auto-transcribe, model selection/download management, summary/ToC generation toggles
- Privacy & Security: listened receipts toggle, backup opt-in, relay configuration
- Storage: usage overview, cleanup tools

## Compliance and privacy
- Permissions: clear in-app rationale for microphone, notifications, and contacts (invite suggestions only)
- Privacy: all AI and search on-device; no cloud AI; transport E2EE; minimal metadata at relays
- Legal: provide privacy policy and EULA; age-appropriate disclosures

## Milestones
- M1: Local core — recording/playback, local storage, delete, basic UI, Settings skeleton
- M2: Transport + E2EE — libsignal sessions, envelopes, media upload/download, receipts, push wake-up
- M3: On-device AI — model manager, post-recording transcription, FTS search, summaries, ToC
- M4: UX polish — mini-player, continuous play, iOS glass accents, Android dynamic color, accessibility
- M5: Hardening — storage warnings, relay redundancy, perf/thermal tuning, optional key export/import

## Risks and mitigations
- On-device AI performance on low-end devices → recommend smaller models, on-demand mode, charge-only processing
- iOS background constraints → background audio mode and clear UX; persist state frequently
- Relay abuse/spam → rate limiting, PoW, invite-only relays
- Protocol complexity → keep relay software minimal, versioned, and open-source; thorough test harnesses

## Non-goals (MVP)
- Multi-device sync
- Cloud AI or cloud transcription
- Remote delete/recall of already delivered messages

## Glossary
- VM: Voice Message
- E2EE: End-to-End Encryption
- ToC: Table of Contents (timestamped, tappable sections)

